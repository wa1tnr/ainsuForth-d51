Script started on Mon 30 Jul 2018 10:36:34 PM UTC

About 565 lines or so in length.

    44a4:	00004265 	.word	0x00004265

 script $ arm-none-eabi-objdump -S -z -I \
    /this/path/sandboxx/AtmelStart.d/atst_D51_aa_rev00d \
    /this/path/sandboxx/AtmelStart.d/atst_D51_aa_rev00d/gcc/AtmelStart.elf 

/this/path/sandboxx/AtmelStart.d/atst_D51_aa_rev00d/gcc/AtmelStart.elf:     file format elf32-littlearm


Disassembly of section .text:

00004000 <exception_table>:
    4000:	30 c0 00 20 61 43 00 00 5d 43 00 00 5d 43 00 00     0.. aC..]C..]C..
    4010:	5d 43 00 00 5d 43 00 00 5d 43 00 00 00 00 00 00     ]C..]C..]C......
    4020:	00 00 00 00 00 00 00 00 00 00 00 00 5d 43 00 00     ............]C..
    4030:	5d 43 00 00 00 00 00 00 5d 43 00 00 5d 43 00 00     ]C......]C..]C..
    4040:	5d 43 00 00 5d 43 00 00 5d 43 00 00 5d 43 00 00     ]C..]C..]C..]C..
    4050:	5d 43 00 00 5d 43 00 00 5d 43 00 00 5d 43 00 00     ]C..]C..]C..]C..
    4060:	5d 43 00 00 5d 43 00 00 5d 43 00 00 5d 43 00 00     ]C..]C..]C..]C..
    4070:	5d 43 00 00 5d 43 00 00 5d 43 00 00 5d 43 00 00     ]C..]C..]C..]C..
    4080:	5d 43 00 00 5d 43 00 00 5d 43 00 00 5d 43 00 00     ]C..]C..]C..]C..
    4090:	5d 43 00 00 5d 43 00 00 5d 43 00 00 5d 43 00 00     ]C..]C..]C..]C..
    40a0:	5d 43 00 00 5d 43 00 00 5d 43 00 00 5d 43 00 00     ]C..]C..]C..]C..
    40b0:	5d 43 00 00 5d 43 00 00 5d 43 00 00 5d 43 00 00     ]C..]C..]C..]C..
    40c0:	5d 43 00 00 5d 43 00 00 5d 43 00 00 5d 43 00 00     ]C..]C..]C..]C..
    40d0:	5d 43 00 00 5d 43 00 00 5d 43 00 00 5d 43 00 00     ]C..]C..]C..]C..
    40e0:	5d 43 00 00 5d 43 00 00 5d 43 00 00 5d 43 00 00     ]C..]C..]C..]C..
    40f0:	00 00 00 00 25 43 00 00 5d 43 00 00 5d 43 00 00     ....%C..]C..]C..
    4100:	5d 43 00 00 5d 43 00 00 5d 43 00 00 5d 43 00 00     ]C..]C..]C..]C..
    4110:	5d 43 00 00 5d 43 00 00 5d 43 00 00 5d 43 00 00     ]C..]C..]C..]C..
    4120:	5d 43 00 00 5d 43 00 00 5d 43 00 00 5d 43 00 00     ]C..]C..]C..]C..
    4130:	5d 43 00 00 5d 43 00 00 5d 43 00 00 5d 43 00 00     ]C..]C..]C..]C..
    4140:	5d 43 00 00 5d 43 00 00 5d 43 00 00 5d 43 00 00     ]C..]C..]C..]C..
    4150:	5d 43 00 00 5d 43 00 00 00 00 00 00 00 00 00 00     ]C..]C..........
    4160:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4170:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4180:	5d 43 00 00 5d 43 00 00 5d 43 00 00 5d 43 00 00     ]C..]C..]C..]C..
    4190:	00 00 00 00 5d 43 00 00 5d 43 00 00 5d 43 00 00     ....]C..]C..]C..
    41a0:	5d 43 00 00 5d 43 00 00 5d 43 00 00 5d 43 00 00     ]C..]C..]C..]C..
    41b0:	5d 43 00 00 5d 43 00 00 5d 43 00 00 5d 43 00 00     ]C..]C..]C..]C..
    41c0:	5d 43 00 00 5d 43 00 00 5d 43 00 00 5d 43 00 00     ]C..]C..]C..]C..
    41d0:	5d 43 00 00 5d 43 00 00 5d 43 00 00 5d 43 00 00     ]C..]C..]C..]C..
    41e0:	5d 43 00 00 5d 43 00 00 5d 43 00 00 5d 43 00 00     ]C..]C..]C..]C..
    41f0:	5d 43 00 00 5d 43 00 00 5d 43 00 00 5d 43 00 00     ]C..]C..]C..]C..
    4200:	5d 43 00 00 00 00 00 00 00 00 00 00 5d 43 00 00     ]C..........]C..
    4210:	5d 43 00 00 5d 43 00 00 5d 43 00 00 5d 43 00 00     ]C..]C..]C..]C..
    4220:	5d 43 00 00 5d 43 00 00 5d 43 00 00 5d 43 00 00     ]C..]C..]C..]C..
    4230:	5d 43 00 00 5d 43 00 00 5d 43 00 00 5d 43 00 00     ]C..]C..]C..]C..
    4240:	5d 43 00 00 5d 43 00 00 5d 43 00 00 5d 43 00 00     ]C..]C..]C..]C..
    4250:	5d 43 00 00 5d 43 00 00 5d 43 00 00 5d 43 00 00     ]C..]C..]C..]C..
    4260:	00 00 00 00                                         ....

00004264 <__do_global_dtors_aux>:
    4264:	b510      	push	{r4, lr}
    4266:	4c05      	ldr	r4, [pc, #20]	; (427c <__do_global_dtors_aux+0x18>)
    4268:	7823      	ldrb	r3, [r4, #0]
    426a:	b933      	cbnz	r3, 427a <__do_global_dtors_aux+0x16>
    426c:	4b04      	ldr	r3, [pc, #16]	; (4280 <__do_global_dtors_aux+0x1c>)
    426e:	b113      	cbz	r3, 4276 <__do_global_dtors_aux+0x12>
    4270:	4804      	ldr	r0, [pc, #16]	; (4284 <__do_global_dtors_aux+0x20>)
    4272:	f3af 8000 	nop.w
    4276:	2301      	movs	r3, #1
    4278:	7023      	strb	r3, [r4, #0]
    427a:	bd10      	pop	{r4, pc}
    427c:	20000000 	.word	0x20000000
    4280:	00000000 	.word	0x00000000
    4284:	000044a8 	.word	0x000044a8

00004288 <frame_dummy>:
    4288:	b508      	push	{r3, lr}
    428a:	4b03      	ldr	r3, [pc, #12]	; (4298 <frame_dummy+0x10>)
    428c:	b11b      	cbz	r3, 4296 <frame_dummy+0xe>
    428e:	4903      	ldr	r1, [pc, #12]	; (429c <frame_dummy+0x14>)
    4290:	4803      	ldr	r0, [pc, #12]	; (42a0 <frame_dummy+0x18>)
    4292:	f3af 8000 	nop.w
    4296:	bd08      	pop	{r3, pc}
    4298:	00000000 	.word	0x00000000
    429c:	20000004 	.word	0x20000004
    42a0:	000044a8 	.word	0x000044a8

000042a4 <_oscctrl_init_sources>:
}

static inline void hri_oscctrl_write_XOSCCTRL_reg(const void *const hw, uint8_t index, hri_oscctrl_xoscctrl_reg_t data)
{
	OSCCTRL_CRITICAL_SECTION_ENTER();
	((Oscctrl *)hw)->XOSCCTRL[index].reg = data;
    42a4:	4b03      	ldr	r3, [pc, #12]	; (42b4 <_oscctrl_init_sources+0x10>)
    42a6:	4a04      	ldr	r2, [pc, #16]	; (42b8 <_oscctrl_init_sources+0x14>)
    42a8:	619a      	str	r2, [r3, #24]
	return (((Oscctrl *)hw)->STATUS.reg & OSCCTRL_STATUS_XOSCRDY0) >> OSCCTRL_STATUS_XOSCRDY0_Pos;
}

static inline bool hri_oscctrl_get_STATUS_XOSCRDY1_bit(const void *const hw)
{
	return (((Oscctrl *)hw)->STATUS.reg & OSCCTRL_STATUS_XOSCRDY1) >> OSCCTRL_STATUS_XOSCRDY1_Pos;
    42aa:	691a      	ldr	r2, [r3, #16]
	        | (CONF_XOSC1_XTALEN << OSCCTRL_XOSCCTRL_XTALEN_Pos) | (CONF_XOSC1_ENABLE << OSCCTRL_XOSCCTRL_ENABLE_Pos));
#endif

#if CONF_XOSC1_CONFIG == 1
#if CONF_XOSC1_ENABLE == 1
	while (!hri_oscctrl_get_STATUS_XOSCRDY1_bit(hw))
    42ac:	0792      	lsls	r2, r2, #30
    42ae:	d5fc      	bpl.n	42aa <_oscctrl_init_sources+0x6>
	hri_oscctrl_set_XOSCCTRL_ONDEMAND_bit(hw, 1);
#endif
#endif

	(void)hw;
}
    42b0:	4770      	bx	lr
    42b2:	bf00      	nop
    42b4:	40001000 	.word	0x40001000
    42b8:	03002606 	.word	0x03002606

000042bc <_oscctrl_init_referenced_generators>:
	while (hri_gclk_read_SYNCBUSY_reg(GCLK))
		;
	hri_gclk_write_GENCTRL_SRC_bf(GCLK, 0, CONF_GCLK_GEN_0_SOURCE);
#endif
	(void)hw;
}
    42bc:	4770      	bx	lr
    42be:	0000      	movs	r0, r0

000042c0 <_init_chip>:
}

static inline void hri_nvmctrl_set_CTRLA_RWS_bf(const void *const hw, hri_nvmctrl_ctrla_reg_t mask)
{
	NVMCTRL_CRITICAL_SECTION_ENTER();
	((Nvmctrl *)hw)->CTRLA.reg |= NVMCTRL_CTRLA_RWS(mask);
    42c0:	4a0a      	ldr	r2, [pc, #40]	; (42ec <_init_chip+0x2c>)
    42c2:	8813      	ldrh	r3, [r2, #0]
    42c4:	b29b      	uxth	r3, r3

/**
 * \brief Initialize the hardware abstraction layer
 */
void _init_chip(void)
{
    42c6:	b510      	push	{r4, lr}
    42c8:	8013      	strh	r3, [r2, #0]
	hri_nvmctrl_set_CTRLA_RWS_bf(NVMCTRL, CONF_NVM_WAIT_STATE);

	_osc32kctrl_init_sources();
    42ca:	4b09      	ldr	r3, [pc, #36]	; (42f0 <_init_chip+0x30>)
	_oscctrl_init_sources();
	_mclk_init();
#if _GCLK_INIT_1ST
	_gclk_init_generators_by_fref(_GCLK_INIT_1ST);
    42cc:	4c09      	ldr	r4, [pc, #36]	; (42f4 <_init_chip+0x34>)
	_osc32kctrl_init_sources();
    42ce:	4798      	blx	r3
	_oscctrl_init_sources();
    42d0:	4b09      	ldr	r3, [pc, #36]	; (42f8 <_init_chip+0x38>)
    42d2:	4798      	blx	r3
	_mclk_init();
    42d4:	4b09      	ldr	r3, [pc, #36]	; (42fc <_init_chip+0x3c>)
    42d6:	4798      	blx	r3
	_gclk_init_generators_by_fref(_GCLK_INIT_1ST);
    42d8:	2008      	movs	r0, #8
    42da:	47a0      	blx	r4
#endif
	_oscctrl_init_referenced_generators();
    42dc:	4b08      	ldr	r3, [pc, #32]	; (4300 <_init_chip+0x40>)
    42de:	4798      	blx	r3
	_gclk_init_generators_by_fref(_GCLK_INIT_LAST);
    42e0:	4623      	mov	r3, r4
    42e2:	f640 70f7 	movw	r0, #4087	; 0xff7

#if CONF_DMAC_ENABLE
	hri_mclk_set_AHBMASK_DMAC_bit(MCLK);
	_dma_init();
#endif
}
    42e6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	_gclk_init_generators_by_fref(_GCLK_INIT_LAST);
    42ea:	4718      	bx	r3
    42ec:	41004000 	.word	0x41004000
    42f0:	000043fd 	.word	0x000043fd
    42f4:	00004305 	.word	0x00004305
    42f8:	000042a5 	.word	0x000042a5
    42fc:	00004319 	.word	0x00004319
    4300:	000042bd 	.word	0x000042bd

00004304 <_gclk_init_generators_by_fref>:
}

void _gclk_init_generators_by_fref(uint32_t bm)
{
#if CONF_GCLK_GEN_0_GENEN == 1
	if (bm & (1ul << 0)) {
    4304:	07c3      	lsls	r3, r0, #31
}

static inline void hri_gclk_write_GENCTRL_reg(const void *const hw, uint8_t index, hri_gclk_genctrl_reg_t data)
{
	GCLK_CRITICAL_SECTION_ENTER();
	((Gclk *)hw)->GENCTRL[index].reg = data;
    4306:	bf42      	ittt	mi
    4308:	4b01      	ldrmi	r3, [pc, #4]	; (4310 <_gclk_init_generators_by_fref+0xc>)
    430a:	4a02      	ldrmi	r2, [pc, #8]	; (4314 <_gclk_init_generators_by_fref+0x10>)
    430c:	621a      	strmi	r2, [r3, #32]
		        | (CONF_GCLK_GEN_11_DIVSEL << GCLK_GENCTRL_DIVSEL_Pos) | (CONF_GCLK_GEN_11_OE << GCLK_GENCTRL_OE_Pos)
		        | (CONF_GCLK_GEN_11_OOV << GCLK_GENCTRL_OOV_Pos) | (CONF_GCLK_GEN_11_IDC << GCLK_GENCTRL_IDC_Pos)
		        | (CONF_GCLK_GEN_11_GENEN << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_11_SOURCE);
	}
#endif
}
    430e:	4770      	bx	lr
    4310:	40001c00 	.word	0x40001c00
    4314:	00010101 	.word	0x00010101

00004318 <_mclk_init>:
}

static inline void hri_mclk_write_CPUDIV_reg(const void *const hw, hri_mclk_cpudiv_reg_t data)
{
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->CPUDIV.reg = data;
    4318:	4b01      	ldr	r3, [pc, #4]	; (4320 <_mclk_init+0x8>)
    431a:	2201      	movs	r2, #1
    431c:	715a      	strb	r2, [r3, #5]
 */
void _mclk_init(void)
{
	void *hw = (void *)MCLK;
	hri_mclk_write_CPUDIV_reg(hw, MCLK_CPUDIV_DIV(CONF_MCLK_CPUDIV));
}
    431e:	4770      	bx	lr
    4320:	40000800 	.word	0x40000800

00004324 <RAMECC_Handler>:
	return tmp;
}

static inline hri_ramecc_intflag_reg_t hri_ramecc_read_INTFLAG_reg(const void *const hw)
{
	return ((Ramecc *)hw)->INTFLAG.reg;
    4324:	4a0b      	ldr	r2, [pc, #44]	; (4354 <RAMECC_Handler+0x30>)
    4326:	7893      	ldrb	r3, [r2, #2]

/**
 * \internal RAMECC interrupt handler
 */
void RAMECC_Handler(void)
{
    4328:	b082      	sub	sp, #8
    432a:	b2db      	uxtb	r3, r3
	struct _ramecc_device *dev      = (struct _ramecc_device *)&device;
	volatile uint32_t      int_mask = hri_ramecc_read_INTFLAG_reg(RAMECC);
    432c:	9301      	str	r3, [sp, #4]

	if (int_mask & RAMECC_INTFLAG_DUALE && dev->ramecc_cb.dual_bit_err) {
    432e:	9b01      	ldr	r3, [sp, #4]
    4330:	0799      	lsls	r1, r3, #30
    4332:	d505      	bpl.n	4340 <RAMECC_Handler+0x1c>
    4334:	4b08      	ldr	r3, [pc, #32]	; (4358 <RAMECC_Handler+0x34>)
    4336:	681b      	ldr	r3, [r3, #0]
    4338:	b113      	cbz	r3, 4340 <RAMECC_Handler+0x1c>
	return tmp;
}

static inline hri_ramecc_erraddr_reg_t hri_ramecc_read_ERRADDR_reg(const void *const hw)
{
	return ((Ramecc *)hw)->ERRADDR.reg;
    433a:	6850      	ldr	r0, [r2, #4]
	} else if (int_mask & RAMECC_INTFLAG_SINGLEE && dev->ramecc_cb.single_bit_err) {
		dev->ramecc_cb.single_bit_err((uint32_t)hri_ramecc_read_ERRADDR_reg(RAMECC));
	} else {
		return;
	}
}
    433c:	b002      	add	sp, #8
		dev->ramecc_cb.single_bit_err((uint32_t)hri_ramecc_read_ERRADDR_reg(RAMECC));
    433e:	4718      	bx	r3
	} else if (int_mask & RAMECC_INTFLAG_SINGLEE && dev->ramecc_cb.single_bit_err) {
    4340:	9b01      	ldr	r3, [sp, #4]
    4342:	07db      	lsls	r3, r3, #31
    4344:	d504      	bpl.n	4350 <RAMECC_Handler+0x2c>
    4346:	4b04      	ldr	r3, [pc, #16]	; (4358 <RAMECC_Handler+0x34>)
    4348:	685b      	ldr	r3, [r3, #4]
    434a:	b10b      	cbz	r3, 4350 <RAMECC_Handler+0x2c>
    434c:	4a01      	ldr	r2, [pc, #4]	; (4354 <RAMECC_Handler+0x30>)
    434e:	e7f4      	b.n	433a <RAMECC_Handler+0x16>
}
    4350:	b002      	add	sp, #8
    4352:	4770      	bx	lr
    4354:	41020000 	.word	0x41020000
    4358:	2000001c 	.word	0x2000001c

0000435c <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
    435c:	e7fe      	b.n	435c <Dummy_Handler>
    435e:	0000      	movs	r0, r0

00004360 <Reset_Handler>:
{
    4360:	b508      	push	{r3, lr}
	if (pSrc != pDest) {
    4362:	4a14      	ldr	r2, [pc, #80]	; (43b4 <Reset_Handler+0x54>)
    4364:	4b14      	ldr	r3, [pc, #80]	; (43b8 <Reset_Handler+0x58>)
    4366:	429a      	cmp	r2, r3
    4368:	d003      	beq.n	4372 <Reset_Handler+0x12>
		for (; pDest < &_erelocate;) {
    436a:	4914      	ldr	r1, [pc, #80]	; (43bc <Reset_Handler+0x5c>)
    436c:	3a04      	subs	r2, #4
    436e:	428b      	cmp	r3, r1
    4370:	d318      	bcc.n	43a4 <Reset_Handler+0x44>
{
    4372:	4b13      	ldr	r3, [pc, #76]	; (43c0 <Reset_Handler+0x60>)
	for (pDest = &_szero; pDest < &_ezero;) {
    4374:	4a13      	ldr	r2, [pc, #76]	; (43c4 <Reset_Handler+0x64>)
		*pDest++ = 0;
    4376:	2100      	movs	r1, #0
	for (pDest = &_szero; pDest < &_ezero;) {
    4378:	4293      	cmp	r3, r2
    437a:	d318      	bcc.n	43ae <Reset_Handler+0x4e>
	SCB->VTOR = ((uint32_t)pSrc & SCB_VTOR_TBLOFF_Msk);
    437c:	4a12      	ldr	r2, [pc, #72]	; (43c8 <Reset_Handler+0x68>)
    437e:	4b13      	ldr	r3, [pc, #76]	; (43cc <Reset_Handler+0x6c>)
    4380:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
    4384:	609a      	str	r2, [r3, #8]
	SCB->CPACR |= (0xFu << 20);
    4386:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
    438a:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
    438e:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
    4392:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    4396:	f3bf 8f6f 	isb	sy
	__libc_init_array();
    439a:	4b0d      	ldr	r3, [pc, #52]	; (43d0 <Reset_Handler+0x70>)
    439c:	4798      	blx	r3
	main();
    439e:	4b0d      	ldr	r3, [pc, #52]	; (43d4 <Reset_Handler+0x74>)
    43a0:	4798      	blx	r3
    43a2:	e7fe      	b.n	43a2 <Reset_Handler+0x42>
			*pDest++ = *pSrc++;
    43a4:	f852 0f04 	ldr.w	r0, [r2, #4]!
    43a8:	f843 0b04 	str.w	r0, [r3], #4
    43ac:	e7df      	b.n	436e <Reset_Handler+0xe>
		*pDest++ = 0;
    43ae:	f843 1b04 	str.w	r1, [r3], #4
    43b2:	e7e1      	b.n	4378 <Reset_Handler+0x18>
    43b4:	000044a8 	.word	0x000044a8
    43b8:	20000000 	.word	0x20000000
    43bc:	20000000 	.word	0x20000000
    43c0:	20000000 	.word	0x20000000
    43c4:	2000002c 	.word	0x2000002c
    43c8:	00004000 	.word	0x00004000
    43cc:	e000ed00 	.word	0xe000ed00
    43d0:	00004441 	.word	0x00004441
    43d4:	000043d9 	.word	0x000043d9

000043d8 <main>:
    init_act_LED();
    blinkLEDfast();
}

int main(void)
{
    43d8:	b508      	push	{r3, lr}
	/* Initializes MCU, drivers and middleware */
	atmel_start_init();
    43da:	4b02      	ldr	r3, [pc, #8]	; (43e4 <main+0xc>)
    43dc:	4798      	blx	r3
        raise_D13();
    43de:	4b02      	ldr	r3, [pc, #8]	; (43e8 <main+0x10>)
    43e0:	4798      	blx	r3
    43e2:	e7fe      	b.n	43e2 <main+0xa>
    43e4:	00004439 	.word	0x00004439
    43e8:	000043ed 	.word	0x000043ed

000043ec <raise_D13>:
	((Port *)hw)->Group[submodule_index].OUTTGL.reg = PORT_OUT_OUT(mask);
}

static inline void hri_port_set_OUT_reg(const void *const hw, uint8_t submodule_index, hri_port_out_reg_t mask)
{
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    43ec:	4b02      	ldr	r3, [pc, #8]	; (43f8 <raise_D13+0xc>)
    43ee:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
    43f2:	619a      	str	r2, [r3, #24]
	                   // <false"> Low
	                   // <true"> High
	                   true);

	// gpio_set_pin_function(D13, GPIO_PIN_FUNCTION_OFF);
}
    43f4:	4770      	bx	lr
    43f6:	bf00      	nop
    43f8:	41008000 	.word	0x41008000

000043fc <_osc32kctrl_init_sources>:
}

static inline hri_osc32kctrl_osculp32k_reg_t hri_osc32kctrl_read_OSCULP32K_CALIB_bf(const void *const hw)
{
	uint32_t tmp;
	tmp = ((Osc32kctrl *)hw)->OSCULP32K.reg;
    43fc:	4b03      	ldr	r3, [pc, #12]	; (440c <_osc32kctrl_init_sources+0x10>)
    43fe:	69da      	ldr	r2, [r3, #28]
	calib = hri_osc32kctrl_read_OSCULP32K_CALIB_bf(hw);
	hri_osc32kctrl_write_OSCULP32K_reg(hw,
#if CONF_OSCULP32K_CALIB_ENABLE == 1
	                                   OSC32KCTRL_OSCULP32K_CALIB(CONF_OSCULP32K_CALIB)
#else
	                                   OSC32KCTRL_OSCULP32K_CALIB(calib)
    4400:	f402 527c 	and.w	r2, r2, #16128	; 0x3f00
}

static inline void hri_osc32kctrl_write_OSCULP32K_reg(const void *const hw, hri_osc32kctrl_osculp32k_reg_t data)
{
	OSC32KCTRL_CRITICAL_SECTION_ENTER();
	((Osc32kctrl *)hw)->OSCULP32K.reg = data;
    4404:	61da      	str	r2, [r3, #28]
	((Osc32kctrl *)hw)->RTCCTRL.reg = data;
    4406:	2201      	movs	r2, #1
    4408:	741a      	strb	r2, [r3, #16]
#endif
#endif

	hri_osc32kctrl_write_RTCCTRL_reg(hw, OSC32KCTRL_RTCCTRL_RTCSEL(CONF_RTCCTRL));
	(void)calib;
}
    440a:	4770      	bx	lr
    440c:	40001400 	.word	0x40001400

00004410 <system_init>:
#include <peripheral_clk_config.h>
#include <utils.h>
#include <hal_init.h>

void system_init(void)
{
    4410:	b508      	push	{r3, lr}
 * Currently the following initialization functions are supported:
 *  - System clock initialization
 */
static inline void init_mcu(void)
{
	_init_chip();
    4412:	4b06      	ldr	r3, [pc, #24]	; (442c <system_init+0x1c>)
    4414:	4798      	blx	r3
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    4416:	4b06      	ldr	r3, [pc, #24]	; (4430 <system_init+0x20>)
    4418:	f44f 0200 	mov.w	r2, #8388608	; 0x800000

static inline void hri_port_write_WRCONFIG_reg(const void *const hw, uint8_t submodule_index,
                                               hri_port_wrconfig_reg_t data)
{
	PORT_CRITICAL_SECTION_ENTER();
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    441c:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    4420:	609a      	str	r2, [r3, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    4422:	6299      	str	r1, [r3, #40]	; 0x28
    4424:	4903      	ldr	r1, [pc, #12]	; (4434 <system_init+0x24>)
    4426:	6299      	str	r1, [r3, #40]	; 0x28
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    4428:	619a      	str	r2, [r3, #24]
	                   // <false"> Low
	                   // <true"> High
	                   true); // please

	// gpio_set_pin_function(D13, GPIO_PIN_FUNCTION_OFF); // would turn that pin off
}
    442a:	bd08      	pop	{r3, pc}
    442c:	000042c1 	.word	0x000042c1
    4430:	41008000 	.word	0x41008000
    4434:	c0000080 	.word	0xc0000080

00004438 <atmel_start_init>:
/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
	system_init();
    4438:	4b00      	ldr	r3, [pc, #0]	; (443c <atmel_start_init+0x4>)
    443a:	4718      	bx	r3
    443c:	00004411 	.word	0x00004411

00004440 <__libc_init_array>:
    4440:	b570      	push	{r4, r5, r6, lr}
    4442:	4e0d      	ldr	r6, [pc, #52]	; (4478 <__libc_init_array+0x38>)
    4444:	4c0d      	ldr	r4, [pc, #52]	; (447c <__libc_init_array+0x3c>)
    4446:	1ba4      	subs	r4, r4, r6
    4448:	10a4      	asrs	r4, r4, #2
    444a:	2500      	movs	r5, #0
    444c:	42a5      	cmp	r5, r4
    444e:	d109      	bne.n	4464 <__libc_init_array+0x24>
    4450:	4e0b      	ldr	r6, [pc, #44]	; (4480 <__libc_init_array+0x40>)
    4452:	4c0c      	ldr	r4, [pc, #48]	; (4484 <__libc_init_array+0x44>)
    4454:	f000 f818 	bl	4488 <_init>
    4458:	1ba4      	subs	r4, r4, r6
    445a:	10a4      	asrs	r4, r4, #2
    445c:	2500      	movs	r5, #0
    445e:	42a5      	cmp	r5, r4
    4460:	d105      	bne.n	446e <__libc_init_array+0x2e>
    4462:	bd70      	pop	{r4, r5, r6, pc}
    4464:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
    4468:	4798      	blx	r3
    446a:	3501      	adds	r5, #1
    446c:	e7ee      	b.n	444c <__libc_init_array+0xc>
    446e:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
    4472:	4798      	blx	r3
    4474:	3501      	adds	r5, #1
    4476:	e7f2      	b.n	445e <__libc_init_array+0x1e>
    4478:	00004494 	.word	0x00004494
    447c:	00004494 	.word	0x00004494
    4480:	00004494 	.word	0x00004494
    4484:	00004498 	.word	0x00004498

00004488 <_init>:
    4488:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    448a:	bf00      	nop
    448c:	bcf8      	pop	{r3, r4, r5, r6, r7}
    448e:	bc08      	pop	{r3}
    4490:	469e      	mov	lr, r3
    4492:	4770      	bx	lr

00004494 <__init_array_start>:
    4494:	00004289 	.word	0x00004289

00004498 <_fini>:
    4498:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    449a:	bf00      	nop
    449c:	bcf8      	pop	{r3, r4, r5, r6, r7}
    449e:	bc08      	pop	{r3}
    44a0:	469e      	mov	lr, r3
    44a2:	4770      	bx	lr

000044a4 <__fini_array_start>:
    44a4:	00004265 	.word	0x00004265
 script $ exit

Script done on Mon 30 Jul 2018 10:40:19 PM UTC
